{"version":3,"sources":["../../src/react/useFormSaver.ts","../../src/react/ReactFormSaver.tsx","../../src/react/index.ts"],"sourcesContent":["import { useEffect, useRef, useCallback } from 'react';\n\n// Helper types\ninterface FormElement extends HTMLElement {\n  value?: string;\n  checked?: boolean;\n  name?: string;\n  type?: string;\n  tagName: string;\n}\n\ninterface FormSaverOptions {\n  debug?: boolean;\n  storagePrefix?: string;\n  ignoredAttributes?: string[];\n  autoSave?: boolean;\n  onRestore?: (element: FormElement, value?: any) => void;\n  onSave?: (element: FormElement, value?: any) => void;\n}\n\n/**\n * React hook version of JqueryFormSaver\n * Automatically saves and restores form values using localStorage\n */\nexport const useFormSaver = (options: FormSaverOptions = {}) => {\n  const {\n    debug = false,\n    storagePrefix = window.location.pathname.replace(/\\/$/, '') + '/formField',\n    ignoredAttributes = ['no-save'],\n    autoSave = true,\n    onRestore,\n    onSave\n  } = options as FormSaverOptions;\n\n  const formRef = useRef<HTMLFormElement>(null);\n  const observerRef = useRef<MutationObserver | null>(null);\n\n  /**\n   * Generate unique identifier for form elements\n   */\n  const generateId = useCallback(() => {\n    return Math.random().toString(36).substr(2, 9);\n  }, []);\n\n  /**\n   * Get unique identifier for form element\n   */\n  const getElementKey = useCallback(\n    (element: FormElement): string => {\n      const id = element.id || element.name || element.getAttribute('data-form-id');\n\n      if (!id) {\n        const newId = generateId();\n        element.setAttribute('data-form-id', newId);\n        return `${storagePrefix}${newId}`;\n      }\n\n      return `${storagePrefix}${id}`;\n    },\n    [generateId, storagePrefix]\n  );\n\n  /**\n   * Check if element should be ignored\n   */\n  const isIgnored = useCallback(\n    (element: FormElement): boolean => {\n      return ignoredAttributes.some(attr => element.hasAttribute(attr));\n    },\n    [ignoredAttributes]\n  );\n\n  /**\n   * Save form element value to localStorage\n   */\n  const saveElementValue = useCallback(\n    (element: FormElement) => {\n      if (isIgnored(element)) return;\n\n      const key = getElementKey(element);\n      const type = element.getAttribute('type');\n\n      try {\n        if (type === 'checkbox') {\n          localStorage.setItem(key, JSON.stringify((element as HTMLInputElement).checked));\n          if (debug) console.log(`Saved checkbox ${key}:`, (element as HTMLInputElement).checked);\n          try {\n            onSave?.(element, (element as HTMLInputElement).checked);\n          } catch (err) {\n            // ignore onSave errors\n          }\n        } else if (type === 'radio') {\n          const name = element.name;\n          if (name) {\n            const radioElements = document.getElementsByName(name) as NodeListOf<HTMLInputElement>;\n            let saved = false;\n            for (let i = 0; i < radioElements.length; i++) {\n              if (radioElements[i].checked) {\n                localStorage.setItem(key, JSON.stringify({ index: i, value: radioElements[i].value }));\n                saved = true;\n                if (debug) console.log(`Saved radio ${key}:`, { index: i, value: radioElements[i].value });\n                break;\n              }\n            }\n            if (!saved) {\n              // nothing selected in the group - remove stale saved value\n              localStorage.removeItem(key);\n              if (debug) console.log(`Removed radio ${key} (no selection)`);\n              try {\n                onSave?.(element, null);\n              } catch (err) {\n                // ignore onSave errors\n              }\n            }\n          }\n        } else {\n          const value = (element as HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement).value;\n          if (value !== '') {\n            localStorage.setItem(key, value);\n            if (debug) console.log(`Saved ${element.tagName.toLowerCase()} ${key}:`, value);\n            try {\n              onSave?.(element, value);\n            } catch (err) {\n              // ignore onSave errors\n            }\n          } else {\n            // cleared by user -> remove stored value so restore won't bring back stale data\n            localStorage.removeItem(key);\n            if (debug) console.log(`Removed ${key} (empty value)`);\n            try {\n              onSave?.(element, null);\n            } catch (err) {\n              // ignore onSave errors\n            }\n          }\n        }\n      } catch (error) {\n        console.error('Error saving form value:', error);\n      }\n    },\n    [getElementKey, isIgnored, debug]\n  );\n\n  /**\n   * Restore form element value from localStorage\n   */\n  const restoreElementValue = useCallback(\n    (element: FormElement) => {\n      // If element is marked ignored (e.g., `no-save`) don't touch it at all.\n      // Previously we cleared ignored inputs which could wipe input fields unexpectedly.\n      if (isIgnored(element)) {\n        return;\n      }\n\n      const key = getElementKey(element);\n      const type = element.getAttribute('type');\n\n      try {\n        if (type === 'checkbox') {\n          const saved = localStorage.getItem(key);\n          if (saved !== null) {\n            const checked = JSON.parse(saved);\n            (element as HTMLInputElement).checked = checked;\n            if (debug) console.log(`Restored checkbox ${key}:`, checked);\n            try {\n              onRestore?.(element, checked);\n            } catch (err) {\n              // ignore onRestore errors\n            }\n            return checked;\n          }\n          return null;\n        } else if (type === 'radio') {\n          const saved = localStorage.getItem(key);\n          if (saved !== null) {\n            const radioData = JSON.parse(saved);\n            const name = element.name;\n            if (name && radioData && typeof radioData.index === 'number') {\n              const radioElements = document.getElementsByName(name) as NodeListOf<HTMLInputElement>;\n              if (radioElements[radioData.index]) {\n                radioElements[radioData.index].checked = true;\n                if (debug) console.log(`Restored radio ${key}:`, radioData);\n                try {\n                  onRestore?.(element, radioData);\n                } catch (err) {\n                  // ignore onRestore errors\n                }\n                return radioData;\n              }\n            }\n            return null;\n          }\n          return null;\n        } else {\n          const saved = localStorage.getItem(key);\n          if (saved !== null) {\n            (element as HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement).value = saved;\n            if (debug) console.log(`Restored ${element.tagName.toLowerCase()} ${key}:`, saved);\n            try {\n              onRestore?.(element, saved);\n            } catch (err) {\n              // ignore onRestore errors\n            }\n            return saved;\n          }\n          return null;\n        }\n      } catch (error) {\n        console.error('Error restoring form value:', error);\n        return null;\n      }\n    },\n    [getElementKey, isIgnored, debug]\n  );\n\n  /**\n   * Clear saved value for element\n   */\n  const clearElementValue = useCallback(\n    (element: FormElement) => {\n      const key = getElementKey(element);\n      localStorage.removeItem(key);\n      if (debug) console.log(`Cleared ${key}`);\n    },\n    [getElementKey, debug]\n  );\n\n  /**\n   * Get all form elements\n   */\n  const getFormElements = useCallback((): FormElement[] => {\n    if (!formRef.current) return [];\n\n    const elements = formRef.current.querySelectorAll('input, textarea, select');\n    return Array.from(elements) as FormElement[];\n  }, []);\n\n  /**\n   * Restore all form values\n   */\n  const restoreForm = useCallback(() => {\n    const elements = getFormElements();\n    elements.forEach(restoreElementValue);\n  }, [getFormElements, restoreElementValue]);\n\n  /**\n   * Save all form values\n   */\n  const saveForm = useCallback(() => {\n    const elements = getFormElements();\n    elements.forEach(saveElementValue);\n  }, [getFormElements, saveElementValue]);\n\n  /**\n   * Clear all saved form values\n   */\n  const clearForm = useCallback(() => {\n    const elements = getFormElements();\n    elements.forEach(clearElementValue);\n  }, [getFormElements, clearElementValue]);\n\n  /**\n   * Handle form element changes\n   */\n  const handleElementChange = useCallback(\n    (event: Event) => {\n      const element = event.target as FormElement;\n      if (element && (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA' || element.tagName === 'SELECT')) {\n        saveElementValue(element);\n      }\n    },\n    [saveElementValue]\n  );\n\n  /**\n   * Setup event listeners and mutation observer\n   */\n  useEffect(() => {\n    if (!formRef.current || !autoSave) return;\n\n    const form = formRef.current;\n\n    // Add change event listeners\n    form.addEventListener('change', handleElementChange);\n    form.addEventListener('input', handleElementChange);\n\n    // Setup mutation observer to handle dynamically added elements\n    observerRef.current = new MutationObserver(mutations => {\n      mutations.forEach(mutation => {\n        mutation.addedNodes.forEach(node => {\n          if (node.nodeType === Node.ELEMENT_NODE) {\n            const element = node as HTMLElement;\n\n            // Check if the added element is a form element\n            if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA' || element.tagName === 'SELECT') {\n              restoreElementValue(element as FormElement);\n            }\n\n            // Check for form elements within the added element\n            const formElements = element.querySelectorAll?.('input, textarea, select');\n            if (formElements) {\n              formElements.forEach(el => restoreElementValue(el as FormElement));\n            }\n          }\n        });\n      });\n    });\n\n    observerRef.current.observe(form, {\n      childList: true,\n      subtree: true\n    });\n\n    // Initial restoration\n    restoreForm();\n\n    return () => {\n      form.removeEventListener('change', handleElementChange);\n      form.removeEventListener('input', handleElementChange);\n\n      if (observerRef.current) {\n        observerRef.current.disconnect();\n      }\n    };\n  }, [autoSave, handleElementChange, restoreForm, restoreElementValue]);\n\n  return {\n    formRef,\n    saveForm,\n    restoreForm,\n    clearForm,\n    saveElementValue,\n    restoreElementValue,\n    clearElementValue\n  };\n};\n\nexport default useFormSaver;\n","import React, { forwardRef, useImperativeHandle } from 'react';\nimport { useFormSaver } from './useFormSaver';\nimport './react-html-attributes';\n\ninterface ReactFormSaverProps {\n  children: React.ReactNode;\n  debug?: boolean;\n  storagePrefix?: string;\n  ignoredAttributes?: string[];\n  autoSave?: boolean;\n  className?: string;\n  onSubmit?: (event: React.FormEvent<HTMLFormElement>) => void;\n  onSave?: (element: HTMLElement, value?: any) => void;\n  onRestore?: (element: HTMLElement, value?: any) => void;\n}\n\nexport interface ReactFormSaverRef {\n  saveForm: () => void;\n  restoreForm: () => void;\n  clearForm: () => void;\n  saveElementValue: (element: HTMLElement) => void;\n  restoreElementValue: (element: HTMLElement) => any;\n  clearElementValue: (element: HTMLElement) => void;\n}\n\n/**\n * React component version of JqueryFormSaver.\n *\n * Wraps form elements and automatically saves/restores their values to\n * web storage (localStorage) using an optional `storagePrefix` key.\n *\n * Usage notes:\n * - Inputs must have a `name` attribute to be saved/restored.\n * - The component restores values into the DOM. If you use controlled React\n *   inputs (value + onChange) you should synchronize the restored DOM value\n *   back into React state after calling `restoreForm()` (see example).\n * - Use the `ignoredAttributes` prop or the `no-save` attribute on an input to\n *   exclude fields (for example OTP codes) from being stored.\n *\n * Examples:\n *\n * 1) Basic usage (uncontrolled inputs or inputs you don't need to sync into state):\n *\n * ```tsx\n * import React, { useRef } from 'react';\n * import { ReactFormSaver, ReactFormSaverRef } from 'jquery-form-saver/react';\n *\n * function ContactForm() {\n *   const ref = useRef<ReactFormSaverRef | null>(null);\n *   return (\n *     <ReactFormSaver ref={ref} storagePrefix=\"contact-form\">\n *       <input name=\"email\" type=\"email\" placeholder=\"Email\" />\n *       <textarea name=\"message\" placeholder=\"Message\" />\n *     </ReactFormSaver>\n *   );\n * }\n * ```\n *\n * 2) Controlled inputs — restore into React state after restore:\n *\n * ```tsx\n * import React, { useRef, useEffect, useState } from 'react';\n * import { ReactFormSaver, ReactFormSaverRef } from 'jquery-form-saver/react';\n *\n * function LoginForm() {\n *   const ref = useRef<ReactFormSaverRef | null>(null);\n *   const [phone, setPhone] = useState('');\n *\n *   useEffect(() => {\n *     // restore DOM values first\n *     ref.current?.restoreForm();\n *     // then sync DOM -> state for controlled inputs\n *     const el = document.querySelector<HTMLInputElement>(\"input[name='phone']\");\n *     if (el?.value) setPhone(el.value);\n *   }, []);\n *\n *   return (\n *     <ReactFormSaver ref={ref} storagePrefix=\"login\">\n *       <input name=\"phone\" value={phone} onChange={e => setPhone(e.target.value)} />\n *     </ReactFormSaver>\n *   );\n * }\n * ```\n *\n * 3) Ignoring OTP fields (do not persist):\n *\n * ```tsx\n * <ReactFormSaver ignoredAttributes={['no-save']}>\n *   <input name=\"im3_phone\" />\n *   <input name=\"im3_otp\" no-save=\"true\" />\n * </ReactFormSaver>\n * ```\n *\n * Methods exposed on the forwarded ref:\n * - `saveForm()` — save current form state\n * - `restoreForm()` — restore saved state into DOM\n * - `clearForm()` — clear saved entries\n * - `saveElementValue(elem)` / `restoreElementValue(elem)` / `clearElementValue(elem)`\n *\n * onSubmit behavior:\n * - If `onSubmit` is provided, the component will intercept the form submit event,\n *   call `saveForm()` to persist values, prevent default browser submission, and\n *   then call the provided `onSubmit` callback with the submit event.\n * - This ensures controlled components can persist DOM values before the\n *   consumer handles the submit logic (e.g., API calls).\n *\n */\nexport const ReactFormSaver = forwardRef<ReactFormSaverRef, ReactFormSaverProps>(\n  (\n    {\n      children,\n      debug = false,\n      storagePrefix,\n      ignoredAttributes = ['no-save'],\n      autoSave = true,\n      className,\n      onSubmit,\n      onSave,\n      onRestore\n    },\n    ref\n  ) => {\n    const { formRef, saveForm, restoreForm, clearForm, saveElementValue, restoreElementValue, clearElementValue } =\n      useFormSaver({\n        debug,\n        storagePrefix,\n        ignoredAttributes,\n        autoSave,\n        onRestore,\n        onSave\n      });\n\n    // Expose methods via ref\n    useImperativeHandle(\n      ref,\n      () => ({\n        saveForm,\n        restoreForm,\n        clearForm,\n        saveElementValue: (element: HTMLElement) => {\n          // hook will call onSave with the saved value, so just delegate\n          saveElementValue(element as any);\n        },\n        restoreElementValue: (element: HTMLElement) => {\n          // The hook already calls onRestore when restoring automatically.\n          // We still return the restored value for callers.\n          return restoreElementValue(element as any);\n        },\n        clearElementValue\n      }),\n  [saveForm, restoreForm, clearForm, saveElementValue, restoreElementValue, clearElementValue, onSave, onRestore, onSubmit]\n    );\n\n    const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n      // Always persist current form values first\n      try {\n        saveForm();\n      } catch (err) {\n        // ignore save errors\n      }\n      // Prevent default browser submission to avoid full page reload.\n      // If a consumer provided an onSubmit handler, call it after preventing default.\n      try {\n        e.preventDefault();\n      } catch (err) {\n        // ignore if preventDefault is unavailable\n      }\n      if (typeof onSubmit === 'function') {\n        onSubmit(e);\n      }\n    };\n\n    return (\n      <form ref={formRef} className={className} onSubmit={handleSubmit} onReset={clearForm}>\n        {children}\n      </form>\n    );\n  }\n);\n\nReactFormSaver.displayName = 'ReactFormSaver';\n\nexport default ReactFormSaver;\n","/**\n * React version of jquery-form-saver\n *\n * This package provides React hooks and components that replicate the functionality\n * of the original jQuery-based form saver, allowing automatic saving and restoration\n * of form values using localStorage.\n */\n\n// Import type extensions for HTML attributes\n// import './react-html-attributes';\n\n// export { useFormSaver } from './useFormSaver';\n// export { ReactFormSaver, type ReactFormSaverRef } from './ReactFormSaver';\n\n// For backward compatibility, also export as default\n// export { useFormSaver as default } from './useFormSaver';\n\nimport './react-html-attributes';\nimport { useFormSaver } from './useFormSaver';\nimport { ReactFormSaver, type ReactFormSaverRef } from './ReactFormSaver';\n\nexport { useFormSaver, ReactFormSaver, type ReactFormSaverRef };\nexport default useFormSaver;\n"],"mappings":"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","names":[]}